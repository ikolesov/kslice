Wherever possible, we are encouraging a user-centered design approach for Slicer3's application and software modules. This approach is built on five principles:

1. Understand who your users are, what they need, and how they work.

2. Engage users in your design and prototyping process.

3. Refine your implementation iteratively with user feedback.

4. Provide documentation that describes your module, its status, its features and how to use them.

5. Monitor and address feedback on software bugs and usability problems. 

 Value and benefit:
In OSS efforts operating in a research setting, software development is often driven principally by feature requirements (a feature-centered design approach) in service of advancing research. Mature tools often evolve from software prototypes designed to test an algorithm, or they’re created for use in a particular research laboratory by experts familiar with the algorithms and their parameterization. Usability issues are often approached after a tool is translated out of the laboratory, long after design and implementation decisions have hardened the underlying technology and the way it’s exposed to users. Asking “what do the users think?” at this point will likely reveal the need for significant re-design and re-engineering that a project can’t afford and developers don’t want to think about.

So, while establishing a clear set of technical requirements is paramount for a tool intended to reach a broad audience and to have a strong impact on scientific research, it’s not necessarily enough! If the software isn’t easy and satisfying for people to use, the tool’s use can be limited or can vanish when a more satisfying alternative becomes available. This outcome minimizes the utility of a team’s or individual’s contribution, and diminishes the impact of a project’s sponsoring agencies or institutions. Sometimes, adoptive user communities spend valuable time drafting and maintaining their own local versions of training materials for unfriendly tools (keeping instructions in binders in the lab, on local wiki pages, etc.) to train new users and support ongoing use. This outcome transfers the time-cost from developers to users (and often multiplies it) – what the development team saves by designing software tools without engaging users, users must spend later by providing in-house help. 